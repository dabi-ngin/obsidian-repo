Following the process of creating [[Tokens|tokens]] with our [[Lexers|lexer]] and then parsing this into the basis of our [[Abstract Syntax Tree|AST]], we then need to actually assign meaningful value to these so that we can start making logical operations. it's no use just returning out a string of braces wrapping an expression as this doesn't allow us to actually do anything with a programming language.

This is also the area in which programming languages and as a consequence, interpreter implementations vary the most. 


### Strategies of Evaluation 
The AST can be evaluated via basic tree traversal algorithms, visiting each note and do what the node itself signifies: print a string, add two numbers, execute a function's body - all on the fly. This approach is called [[Tree Walking Interpretation|tree walking interpretation]], the archetype of interpreters.

Sometimes, the evaluation step is preceded by small optimisations that rewrite the AST (e.g. remove unused variable bindings) or convert it into another intermediate representation (IR) that's more suitable for recursive and repeated evaluation.

Other interpreters also traverse the AST, but instead of interpreting the AST itself they first convert it to bytecode. [[Bytecode]] is another IR of the AST and a very dense one. The exact format of which [[Opcodes|opcodes ]] it's composed of varies and depends on the guest/host programming languages. 

Just-in-time or "JIT" is a blurry line between Interpreters and compilers where the generated bytecode is then compiled directly to machine code, right before being executed, just in time. 

Some skip the compilation to bytecode, they just recursively evaluate the AST and only after evaluating a particular branch of the AST multiple times does it compile the branch to machine code. 

